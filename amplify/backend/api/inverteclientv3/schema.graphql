input AMPLIFY {
    globalAuthRule: AuthRule = { allow: public }
} # FOR TESTING ONLY!
type Restaurant @model {
    restaurant_id: ID! @primaryKey
    demo: String
    iotThingNames: AWSJSON
    restaurantLocationNum: String
    displayIngredient: Int
    restaurantName: String
    unitOfMass: String
    timeZone: String
    accessType: String
}
type Day @model {
    dayOfYear_iotNameThing: ID! @primaryKey
    weekOfYear_iotNameThing: ID! @index(name: "byWeek")
    monthOfYear_iotNameThing: String!
    year_iotNameThing: String
    dailySummary: DailySummary
    realTime: AWSJSON
    dashboardGraph: AWSJSON
    scaleActions: AWSJSON
    allPortionEvents: AWSJSON
    createdAt: String!
    hour: [Hour] @hasMany(indexName: "byDay")
}

type Hour @model {
    dayOfYear_hourOfDay_iotNameThing: ID! @primaryKey
    dayOfYear_iotNameThing: ID! @index(name: "byDay")
    hourlySummary: HourlySummary
    realTime: AWSJSON!
    scaleActions: AWSJSON
    createdAt: String!
}

type Subscription {
    onNewPortionEvent: Day @aws_subscribe(mutations: ["updateDay"])
}

input HourlySummaryInput {
    averageTime: Float!
    portionsCompleted: Int!
    accuracy: Float!
    inventoryConsumed: Int!
    overServed: Int
    underServed: Int
    perfect: Int
    precision: Float
}

input DailySummaryInput {
    averageTime: Float!
    portionsCompleted: Int!
    accuracy: Float!
    inventoryConsumed: Int!
    overServed: Int
    underServed: Int
    perfect: Int
    precision: Float
}
type HourlySummary {
    averageTime: Float!
    portionsCompleted: Int!
    accuracy: Float!
    inventoryConsumed: Int!
    overServed: Int
    underServed: Int
    perfect: Int
    precision: Float
    hour: Hour
}

type DailySummary {
    averageTime: Float!
    portionsCompleted: Int!
    accuracy: Float!
    inventoryConsumed: Int!
    overServed: Int
    underServed: Int
    perfect: Int
    day: Day
    precision: Float
}
